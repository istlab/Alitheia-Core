<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="devel">
  <title>Developing for SQO-OSS</title>
  <sect1 id="devel:arch">
    <title>Architectural Overview</title>
    <para></para>
    <sect2 id="devel:arch:tds">
      <title>Thin Data Access - TDS</title>
      <para></para>
    </sect2>
    <sect2 id="devel:arch:fds">
      <title>Fat Data Access - FDS</title>
      <para></para>
    </sect2>
    <sect2 id="devel:arch:db">
      <title>Database Service</title>
      <para>

          First, why a new DBService API? Because we realised that the
          previous API had shortcomings regarding lazy-loading of collections
          with DAOs (e.g project.getVersions()), and there were scenarios that
          were not taken into account which made it impossible to work reliably
          with DAOs.

          Also, we realised that the API was too complicated to use and
          required a deep understanding of Hibernate from users, which was
          sort of defeating the purpose of the DBService in the first place.
          (as an example, almost all the code using the DBService in Alitheia
          was more or less wrong or incomplete)

          So the aim for the new API was to make work with the DAOs as intuitive
          and simple as possible, and hiding all the Hibernate specifics.
          Basically, all the complicated Session and Transaction
          stuff is gone, as well as all the exception handling.

          The good news is, most of the methods from the previous API are
          still there, such as findObjectById, findObjectByProperties,
          addRecord/deleteRecord, and doHQL.
          However, you will notice that all the overloads taking a Session
          argument are gone, as you don't need to manipulate those anymore.

          On the other hand, four new methods have appeared :

- startDBSession()
- commitDBSession()
- rollbackDBSession()
- isDBSessionActive()

These methods are used to control the connection to the database and the DAOs.
Basically, all the queries, DAO manipulation, and insertions/deletions have to
happen within a database session, which you can see as a connection to the
database with a transaction open.
startDBSession() is the method which starts a new session, and commitDBSession()
and rollbackDBSession() end it, either by committing the modifications in the
database or just discarding them.
Finally, isDBSessionActive() tells you if a session is currently opened or not.

Regarding the DAOs, they remain "connected" as long as the session is open,
meaning they will load collections and properties and automatically persist
changes you make to them (provided you commit the changes at the end of the
session). This means no more need for updateRecord(), as modifying the DAO
directly is now enough.
Note that you can still access loaded DAOs even after the database session was
closed, but lazy-loading won't work and modifications won't be saved, EVEN IF
YOU OPEN A NEW DATABASE SESSION. In other words, DAOs belong to the session that
created them only. (I might add a possibility to "reattach" them to another
session later on).

Another important thing: the DBService is thread-safe. this means you can safely
call all of its methods simultaneously from multiple threads without risks of
race conditions or weird behaviour.
In particular, each thread has its own session, so the modifications you make in
your session aren't affecting sessions in other threads, especially as opening a
session automatically starts a database transaction, meaning the database is
locked for your thread only. (note: this means you should be VERY careful about
always properly closing a session and keeping them as short as possible).

Finally, exception handling has been completely removed for simplicity's sake.
Instead, methods like addRecord or deleteRecord return a boolean value
indicating success or not. For queries and the find methods,
null/emptyCollection will be returned in case of an error. The important thing
to know is that Hibernate requires a session to be closed as soon as an
exception is thrown from its code, which means in some cases your session might
be automatically closed during a method call. (if you need to make the
difference between no result returned or an error that occured, you can use
isDBSessionActive() )

      </para>
    </sect2>
    <sect2 id="devel:arch:pa">
      <title>Plug-in Administrator</title>
      <para></para>
    </sect2>
    <sect2 id="devel:arch:updater">
      <title>Updater</title>
      <para></para>
    </sect2>
  </sect1>

  <sect1 id="devel:plugins">
    <title>Developing Plugins</title>
    <para>
      In this section, we provide an overview of how plug-ins work in
      Alitheia.
    </para>
    <sect2 id="devel:plugins:quick">
      <title>Quick and dirty guide</title>
      <para>
        To follow the instructions replace:
        <itemizedlist mark='opencircle'>
          <listitem>
            <para>
              <command>$ALITHEIA</command>
              with path where you unbundled or checked out the Alitheia
              source code distribution.
            </para>
          </listitem>
          <listitem>
            <para>
              <command>$YOURMETRIC</command>
              with the symbolic name of you metric
            </para>
          </listitem>
        </itemizedlist>
        Then, you do:
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              <command>
                svn cp $ALITHEIA/metrics/skeleton
                $ALITHEIA/metrics/$YOURMETRIC
              </command>
            </para>
          </listitem>
          <listitem>
            <para>
              Change the name of the packages:
              <itemizedlist mark='opencircle'>
                <listitem>
                  <para>
                    <classname>
                      eu.sqooss.impl.metrics.skeleton
                    </classname>
                    to
                    <classname>
                      eu.sqooss.impl.metrics.$YOURMETRIC
                    </classname>
                  </para>
                </listitem>
                <listitem>
                  <para>
                    <classname>eu.sqooss.metrics.skeleton</classname>
                    to
                    <classname>eu.sqooss.metrics.$YOURMETRIC</classname>
                  </para>
                </listitem>
              </itemizedlist>
            </para>
          </listitem>
          <listitem>
            <para>
              Change the name of the classes:
              <itemizedlist mark='opencircle'>
                <listitem>
                  <para>
                    <classname>
                      eu.sqooss.impl.metrics.skeleton.SkeletomImplemenation
                    </classname>
                    to
                    <classname>

eu.sqooss.impl.metrics.$YOURMETRIC.$YOURMETRICImplementation
                    </classname>
                  </para>
                </listitem>
                <listitem>
                  <para>
                    <classname>
                      eu.sqooss.impl.service.SkeletonActivator
                    </classname>
                    to
                    <classname>
                      eu.sqooss.impl.service.$YOURMETRICActivator
                    </classname>
                  </para>
                </listitem>
                <listitem>
                  <para>
                    <classname>
                      eu.sqooss.metrics.skeleton.Skeleton
                    </classname>
                    to
                    <classname>
                      eu.sqooss.metrics.$YOURMETRIC.$YOURMETRIC
                    </classname>
                  </para>
                </listitem>
              </itemizedlist>
            </para>
          </listitem>
          <listitem>
            <para>
              Add the required interfaces to the definition of the
              <classname>
                eu.sqooss.metrics.$YOURMETRIC.$YOURMETRIC
              </classname>
              interface
            </para>
          </listitem>
          <listitem>
            <para>
              Implement one job for each metric your plug-in calculates.
              This can be performed by copying the class
              <classname>
                eu.sqooss.metrics.skeleton.SkeletonJob
              </classname>
              to
              <classname>
                eu.sqooss.metrics.$YOURMETRIC.$YOURMETRICJob
              </classname>
            </para>
          </listitem>
          <listitem>
            <para>
              Implement the required
              <methodname>getResult(*)</methodname>
              and
              <methodname>run(*)</methodname>
              methods in the class
              <classname>
                eu.sqooss.impl.metrics.$YOURMETRIC.$YOURMETRICImplementation
              </classname>
            </para>
          </listitem>
          <listitem>
            <para>
              Change the following entries in the manifest file (
              <filename>$ALITHEIA/metrics/$YOURMETRIC/manifest</filename>)
              to much your metric
              <itemizedlist>
                <listitem>
                  <para>Bundle-SymbolicName</para>
                </listitem>
                <listitem>
                  <para>Bundle-Activator</para>
                </listitem>
                <listitem>
                  <para>Bundle-Description</para>
                </listitem>
                <listitem>
                  <para>Bundle-Name</para>
                </listitem>
              </itemizedlist>
            </para>
          </listitem>
          <listitem>
            <para>
              Modify the <filename>pom.xml</filename> to match your
              metric configuration
            </para>
          </listitem>
        </orderedlist>
      </para>
      <para>
      If you follow these steps closely, you will have a metric bundle
      that can be loaded in Alitheia, start its own metric jobs and
      retrieve results from the database. All you need to do now is to
      implement the <methodname>run()</methodname> method in each
      metric job.
      </para>
    </sect2>
    <sect2>
    <title>Developing plug-ins</title>
    <sect3 id="devel:plugins:defs">
      <title>Definitions</title>
      <para>Following is a list of definitions of common terms in the
      context of SQO-OSS</para>
      <variablelist>
      <varlistentry>
          <term>Plugin</term>
          <listitem>
              <para>
                  An OSGi bundle that implements and exports the
                  <classname>eu.sqooss.service.abstactmetric.AlitheiaPlugin
                  </classname>
                  interface
              </para>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term>Asset</term>
          <listitem>
              <para>
                  A collection of development data, such as a source code
                  repository, a mailing list or a bug managemnet database
              </para>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term>Project</term>
          <listitem>
              <para>
                  A set of assets consisting of at least a Subversion
                  repository and additionally a collection of mailing
                  lists and a bug management system
              </para>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term>Metric</term>
          <listitem>
              <para>
                  An algorith that evaluates a property of a project
                  asset or a change in a project asset and returns a result
              </para>
          </listitem>
      </varlistentry>
      </variablelist>
    </sect3>
    <sect3 id="devel:plugins:general">
      <title>General</title>
      <para>
          <itemizedlist mark='opencircle'>
          <listitem>
            <para>
                Plugins define one or more metrics. A metric operates on
                a project asset and produces results.
            </para>
          </listitem>
          <listitem>
            <para>
                Metrics can produce an arbitrary set of results per evaluated
                project asset. Metric results can be of arbitrary datatypes.
                Metric results always have a mime type attached.
            </para>
          </listitem>
          <listitem>
            <para>
                The result of a metric calculation is stored in the database.
                The Alitheia system provides a default storage facility for
                metrics for each one of the evaluated project assets. The
                default storage facility can only store a single value for
                each metric per evaluated resource type. However, plug-ins are
                free to implement custom DB tables for intermediate or final
                results, provided that the final results are associated with
                the project asset on which the metric operated.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect3>
    <sect3 id="devel:plugins:activation">
      <title>Plugin Activation</title>
      <para>
          Each plug-in is associated with a set of activation types. An
          activation type indicates that a plug-in should be activated to
          evaluate new project data when the corresponding project assets have
          been updated. Also, the plug-in can only return metric results
          for the supported activation types. An activation type is essentially
          the class type for the DAO that represents the asset type that the
          plug-in defined metrics can evaluate.
      </para>
      <para>
          Currently, the supported activation types are the following:
      <variablelist>
      <varlistentry>
          <term><classname>StoredProject</classname></term>
          <listitem>
              <para>
                  Project wide activations. Plug-ins
                  implementing this activation type are triggered when
                  a new project is added to the system. Metrics might
                  can use this activation type to store project wide
                  results
              </para>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term><classname>ProjectVersion</classname></term>
          <listitem>
              <para>
                  Per-version activations. Metrics are activated when the
                  a new project version is commited to the source code
                  repository.
              </para>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term><classname>ProjectFile</classname></term>
          <listitem>
              <para>
                  Per-file activations. Metrics are activated when a project
                  file has been added, changed or removed from the source code
                  repository.
              </para>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term><classname>FileGroup</classname></term>
          <listitem>
              <para>
                  Per-filegroup activations. Metrics are activated when
                  the file group has changed, e.g. a when a file was modified
                  in a regular expression based file group.
              </para>
          </listitem>
      </varlistentry>
      </variablelist>
      More activation types will be supported as the corresponding subsystems
      continue to develop.
      </para>
      <para>
          To denote their support for an activation type, plug-ins must implement
          one or more of the interfaces residing under <classname>
          eu.sqooss.service.abstractmetric</classname>.
      </para>
    </sect3>
    <sect3 id="devel:plugins:iface">
      <title>The AlitheiaPlugin interface</title>
      <para>
      <programlisting>
public interface AlitheiaPlugin {
    String getVersion();
    String getAuthor();
    Date getDateInstalled();
    String getName();
    String getDescription();
    Result getResult(DAObject o, List&lt;Metric&gt; l)
        throws MetricMismatchException;
    void run(DAObject o)
        throws MetricMismatchException;
    boolean update();
    boolean install();
    boolean remove();
    String getUniqueKey();
    List &lt;Class&lt;? extends DAObject&gt;&gt; getActivationTypes();
    List&lt;PluginConfiguration&gt; getConfigurationSchema();
}
      </programlisting>
    </para>
    </sect3>
    <sect3 id="devel:plugins:implscr">
      <title>Implementing a plug-in from scratch</title>
      <para></para>
    </sect3>
    </sect2>
  </sect1>
</chapter>
