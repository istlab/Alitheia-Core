<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>UpdaterServiceImpl.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">JUnit (Jan 15, 2015 3:49:07 PM)</a> &gt; <a href="../../index.html" class="el_group">core</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">eu.sqooss.impl.service.updater</a> &gt; <span class="el_source">UpdaterServiceImpl.java</span></div><h1>UpdaterServiceImpl.java</h1><pre class="source lang-java linenums">/*
 * This file is part of the Alitheia system, developed by the SQO-OSS
 * consortium as part of the IST FP6 SQO-OSS project, number 033331.
 *
 * Copyright 2008 - 2010 - Organization for Free and Open Source Software,
 *                 Athens, Greece.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package eu.sqooss.impl.service.updater;

import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import org.osgi.framework.BundleContext;
import org.osgi.framework.ServiceReference;

import eu.sqooss.core.AlitheiaCore;
import eu.sqooss.service.cluster.ClusterNodeActionException;
import eu.sqooss.service.cluster.ClusterNodeService;
import eu.sqooss.service.db.ClusterNode;
import eu.sqooss.service.db.DBService;
import eu.sqooss.service.db.StoredProject;
import eu.sqooss.service.logging.Logger;
import eu.sqooss.service.scheduler.Job;
import eu.sqooss.service.scheduler.Job.State;
import eu.sqooss.service.scheduler.JobStateListener;
import eu.sqooss.service.scheduler.SchedulerException;
import eu.sqooss.service.tds.InvalidAccessorException;
import eu.sqooss.service.tds.ProjectAccessor;
import eu.sqooss.service.tds.TDSService;
import eu.sqooss.service.updater.MetadataUpdater;
import eu.sqooss.service.updater.Updater;
import eu.sqooss.service.updater.UpdaterService;
import eu.sqooss.service.util.BidiMap;
import eu.sqooss.service.util.GraphTS;

<span class="nc" id="L72">public class UpdaterServiceImpl implements UpdaterService, JobStateListener {</span>

<span class="nc" id="L74">    private Logger logger = null;</span>
<span class="nc" id="L75">    private AlitheiaCore core = null;</span>
    private BundleContext context;
<span class="nc" id="L77">    private DBService dbs = null;</span>
    
    /* Maps project-ids to the jobs that have been scheduled for 
     * each update target*/
    private ConcurrentMap&lt;Long,Map&lt;Updater, UpdaterJob&gt;&gt; scheduledUpdates;
    
    /* List of registered updaters */
    private BidiMap&lt;Updater, Class&lt;? extends MetadataUpdater&gt;&gt; updaters;

    /* UpdaterService interface methods*/
    /** {@inheritDoc} */
    @Override
    public void registerUpdaterService(Class&lt;? extends MetadataUpdater&gt; clazz) {

<span class="nc" id="L91">        Updater u = clazz.getAnnotation(Updater.class);</span>

<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (u == null) {</span>
<span class="nc" id="L94">            logger.error(&quot;Class &quot; + clazz + &quot; is missing required annotation&quot; +</span>
<span class="nc" id="L95">            		&quot; @Updater&quot;);</span>
<span class="nc" id="L96">            return;</span>
        }

<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (getUpdaterByMnemonic(u.mnem()) != null) {</span>
<span class="nc" id="L100">            logger.error(&quot;Mnemonic already used by updater &quot; </span>
<span class="nc" id="L101">                    + updaters.get(getUpdaterByMnemonic(u.mnem())));</span>
<span class="nc" id="L102">            return;</span>
        }
        
        
        
<span class="nc" id="L107">        updaters.put(u, clazz);</span>
            
<span class="nc" id="L109">        logger.info(&quot;Registering updater class &quot; + clazz.getCanonicalName() + </span>
<span class="nc" id="L110">                &quot; for protocols (&quot; + Arrays.toString(u.protocols()) +</span>
<span class="nc" id="L111">                &quot;) and stage &quot; + u.stage());</span>
<span class="nc" id="L112">    }</span>

    /** {@inheritDoc} */
    @Override
    public void unregisterUpdaterService(Class&lt;? extends MetadataUpdater&gt; clazz) {
<span class="nc" id="L117">        updaters.remove(updaters.getKey(clazz));</span>
<span class="nc" id="L118">        logger.info(&quot;Unregistering updater class &quot; + clazz.getCanonicalName());</span>
<span class="nc" id="L119">    }</span>
    
    /**{@inheritDoc}*/
    @Override
    public boolean update(StoredProject project) {
<span class="nc" id="L124">        return update(project, null, null);</span>
    }
    
    /**{@inheritDoc}*/
    @Override
    public boolean update(StoredProject project, UpdaterStage stage) {
<span class="nc" id="L130">        return update(project, stage, null);</span>
    }
    
    /**{@inheritDoc}*/
    @Override
    public boolean update(StoredProject sp, Updater u) {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (!getUpdaters(sp).contains(u))</span>
<span class="nc" id="L137">            return false;</span>
<span class="nc" id="L138">        return update(sp, null, u);</span>
    }
    
    /**{@inheritDoc}*/
    @Override
    public boolean update(StoredProject sp, String updater) {
<span class="nc" id="L144">        Updater u = getUpdaterByMnemonic(updater);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (u == null) {</span>
<span class="nc" id="L146">            logger.warn(&quot;No such updater: &quot; + updater);</span>
<span class="nc" id="L147">            return false;</span>
        }
<span class="nc" id="L149">        return update(sp, u);</span>
    }

    /**{@inheritDoc}*/
    @Override
    public Set&lt;Updater&gt; getUpdaters(StoredProject project) {
<span class="nc" id="L155">        Set&lt;Updater&gt; upds = new HashSet&lt;Updater&gt;();</span>
<span class="nc" id="L156">        TDSService tds = AlitheiaCore.getInstance().getTDSService();</span>
<span class="nc" id="L157">        ProjectAccessor pa = tds.getAccessor(project.getId());</span>
<span class="nc" id="L158">        Set&lt;URI&gt; schemes = new HashSet&lt;URI&gt;();</span>

        //Import phase updaters
        try {
<span class="nc" id="L162">            schemes.addAll(pa.getSCMAccessor().getSupportedURLSchemes());</span>
<span class="nc" id="L163">            schemes.addAll(pa.getBTSAccessor().getSupportedURLSchemes());</span>
<span class="nc" id="L164">            schemes.addAll(pa.getMailAccessor().getSupportedURLSchemes());</span>
<span class="nc" id="L165">        } catch (InvalidAccessorException e) {</span>
<span class="nc" id="L166">            logger.warn(&quot;Project &quot; + project</span>
<span class="nc" id="L167">                    + &quot; does not include a Mail accessor: &quot; + e.getMessage());</span>
        }

<span class="nc bnc" id="L170" title="All 2 branches missed.">        for (URI uri : schemes) {</span>
<span class="nc" id="L171">            upds.addAll(getUpdatersByProtocol(uri.getScheme()));</span>
        }
        
        //Other updaters
<span class="nc" id="L175">        upds.addAll(getUpdatersByStage(UpdaterStage.PARSE));</span>
<span class="nc" id="L176">        upds.addAll(getUpdatersByStage(UpdaterStage.INFERENCE));</span>
<span class="nc" id="L177">        upds.addAll(getUpdatersByStage(UpdaterStage.DEFAULT));</span>
        
<span class="nc" id="L179">        return upds;</span>
    }
    
    /**{@inheritDoc}*/
    @Override
    public Set&lt;Updater&gt; getUpdaters(StoredProject sp, UpdaterStage st) {
<span class="nc" id="L185">        Set&lt;Updater&gt; upd = new HashSet&lt;Updater&gt;();</span>
        
<span class="nc bnc" id="L187" title="All 2 branches missed.">        for (Updater updater : getUpdaters(sp)) {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (updater.stage().equals(st))</span>
<span class="nc" id="L189">                upd.add(updater);</span>
        }
<span class="nc" id="L191">        return upd;</span>
    }

    /** {@inheritDoc}}*/
    public synchronized boolean isUpdateRunning(StoredProject p, Updater u) {
<span class="nc" id="L196">        Map&lt;Updater, UpdaterJob&gt; m = scheduledUpdates.get(p.getId());</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (m == null) {</span>
            // Nothing in progress
<span class="nc" id="L199">            return false;</span>
        }

<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (m.keySet().contains(u)) {</span>
<span class="nc" id="L203">            return true;</span>
        }
<span class="nc" id="L205">        return false;</span>
    }
    
    /* AlitheiaCoreService interface methods*/
    @Override
    public void shutDown() {
        
<span class="nc" id="L212">    }</span>

    @Override
    public boolean startUp() {
<span class="nc" id="L216">        core = AlitheiaCore.getInstance();</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (logger != null) {</span>
<span class="nc" id="L218">            logger.info(&quot;Got a valid reference to the logger&quot;);</span>
<span class="nc" id="L219">        } else {</span>
<span class="nc" id="L220">            System.out.println(&quot;ERROR: Updater got no logger&quot;);</span>
        }
        
<span class="nc" id="L223">        dbs = core.getDBService();</span>
        
<span class="nc" id="L225">        updaters = new BidiMap&lt;Updater, Class&lt;? extends MetadataUpdater&gt;&gt;();</span>
<span class="nc" id="L226">        scheduledUpdates = new ConcurrentHashMap&lt;Long, Map&lt;Updater, UpdaterJob&gt;&gt;();</span>
        
<span class="nc" id="L228">        logger.info(&quot;Succesfully started updater service&quot;);</span>
<span class="nc" id="L229">        return true;</span>
    }

    @Override
    public void setInitParams(BundleContext bc, Logger l) {
<span class="nc" id="L234">        this.context = bc;</span>
<span class="nc" id="L235">        this.logger = l;</span>
<span class="nc" id="L236">    }</span>

    /*Private service methods*/
    private List&lt;Updater&gt; getUpdatersByProtocol(String protocol) {
<span class="nc" id="L240">        List&lt;Updater&gt; upds = new ArrayList&lt;Updater&gt;();</span>
        
<span class="nc bnc" id="L242" title="All 2 branches missed.">        for (Updater u : updaters.keySet()) {</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            for (String p : u.protocols()) {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                if (protocol.equals(p)) {</span>
<span class="nc" id="L245">                    upds.add(u);</span>
<span class="nc" id="L246">                    break;</span>
                }
            }
        }
        
<span class="nc" id="L251">        return upds;</span>
    }
 
    private List&lt;Updater&gt; getUpdatersByStage(UpdaterStage u) {
<span class="nc" id="L255">        List&lt;Updater&gt; upds = new ArrayList&lt;Updater&gt;();</span>
       
<span class="nc bnc" id="L257" title="All 2 branches missed.">        for (Updater upd : updaters.keySet()) {</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">            if (upd.stage().equals(u))</span>
<span class="nc" id="L259">                upds.add(upd);</span>
        }
        
<span class="nc" id="L262">        return upds;</span>
    }
    
    private Updater getUpdaterByMnemonic(String updater) {
<span class="nc bnc" id="L266" title="All 2 branches missed.">        for (Updater upd : updaters.keySet()) {</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if (upd.mnem().equals(updater))</span>
<span class="nc" id="L268">                return upd;</span>
        }
<span class="nc" id="L270">        return null;</span>
    }

    private boolean checkDependencies(Updater upd) {
<span class="nc" id="L274">        boolean met = true;</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        for (String dep : upd.dependencies()) {</span>
<span class="nc" id="L276">            boolean found = false;</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            for (Updater other : updaters.keySet()) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">                if (dep.equals(other.mnem())) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                    if (other.stage().equals(upd.stage())) {</span>
<span class="nc" id="L280">                        found = true;</span>
<span class="nc" id="L281">                        break;</span>
                    } else {
<span class="nc" id="L283">                        logger.error(&quot;Updater &lt;&quot; + upd.mnem() + &quot;&gt;-&quot; + </span>
<span class="nc" id="L284">                                upd.stage() + </span>
<span class="nc" id="L285">                                &quot; depends on other stage updater &lt;&quot; </span>
<span class="nc" id="L286">                                + other.mnem() + &quot;&gt;-&quot; + other.stage());</span>
<span class="nc" id="L287">                        return false;</span>
                    }
                }
            }
<span class="nc" id="L291">            met &amp;= found;</span>
        }
<span class="nc" id="L293">        return met;</span>
    }
    
    /**
     * Add an update job of the given type or the specific updater for the project. 
     */
    private boolean update(StoredProject project, UpdaterStage stage, Updater updater) {
        
<span class="nc" id="L301">        ClusterNodeService cns = null;</span>
        
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (project == null) {</span>
<span class="nc" id="L304">            logger.info(&quot;Bad project name for update.&quot;);</span>
<span class="nc" id="L305">            return false;</span>
        }     
        
         /// ClusterNode Checks - Clone to MetricActivatorImpl
<span class="nc" id="L309">        cns = core.getClusterNodeService();</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (cns==null) {</span>
<span class="nc" id="L311">            logger.warn(&quot;ClusterNodeService reference not found &quot; +</span>
            		&quot;- ClusterNode assignment checks will be ignored&quot;);
<span class="nc" id="L313">        } else {            </span>
           
<span class="nc" id="L315">            ClusterNode node = project.getClusternode();</span>
            
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (node == null) {</span>
<span class="nc" id="L318">                logger.warn(&quot;Project &quot; + project + </span>
<span class="nc" id="L319">                        &quot; not assigned to any cluster node&quot;);</span>
<span class="nc" id="L320">            } else { </span>
                // project is assigned , check if it is assigned to this Node
<span class="nc bnc" id="L322" title="All 2 branches missed.">                if (!cns.isProjectAssigned(project)) {</span>
<span class="nc" id="L323">                    logger.warn(&quot;Project &quot; + project.getName() + </span>
<span class="nc" id="L324">                            &quot; is not assigned to this ClusterNode - Ignoring update&quot;);</span>
                    // TODO: Clustering - further implementation:
                    // If needed, forward Update to the appropriate ClusterNode!
<span class="nc" id="L327">                    return true;   </span>
                }                
            }
        }  
       
<span class="nc" id="L332">        logger.info(&quot;Request to update project:&quot; + project.getName()  </span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                + &quot; stage:&quot; + (stage == null?stage:&quot;all&quot;) </span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                + &quot; updater:&quot; + (updater == null?updater:&quot;all&quot;));</span>
        
        //Construct a list of updater stages to iterate later
<span class="nc" id="L337">        List&lt;UpdaterStage&gt; stages = new ArrayList&lt;UpdaterStage&gt;(); </span>
        
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (updater == null) {</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            if (stage == null) {</span>
<span class="nc" id="L341">                stages.add(UpdaterStage.IMPORT);</span>
<span class="nc" id="L342">                stages.add(UpdaterStage.PARSE);</span>
<span class="nc" id="L343">                stages.add(UpdaterStage.INFERENCE);</span>
<span class="nc" id="L344">                stages.add(UpdaterStage.DEFAULT);</span>
<span class="nc" id="L345">            } else {</span>
<span class="nc" id="L346">                stages.add(stage);</span>
            }
<span class="nc" id="L348">        } else {</span>
<span class="nc" id="L349">            stages.add(updater.stage());</span>
        }
        
        /*
         * For each update stage add updaters in topologically sorted order. Add
         * dependencies to jobs to serialize execution between updaters in the
         * same stage and add fake dependency jobs to serialise execution among
         * stages. The result of this loop is a list of jobs with properly set
         * dependencies to ensure correct execution.
         */
<span class="nc" id="L359">        List&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();</span>
<span class="nc" id="L360">        BidiMap&lt;Updater, Job&gt; toSchedule = new BidiMap&lt;Updater, Job&gt;();</span>
<span class="nc" id="L361">        DependencyJob oldDepJob = null;</span>
        try {
<span class="nc bnc" id="L363" title="All 2 branches missed.">            for (UpdaterStage us : stages) {</span>
                
                // Topologically sort updaters within the same stage
<span class="nc" id="L366">                List&lt;Updater&gt; updForStage = new ArrayList&lt;Updater&gt;();</span>
<span class="nc" id="L367">                updForStage.addAll(getUpdaters(project, us));</span>
<span class="nc" id="L368">                GraphTS&lt;Updater&gt; graph = </span>
<span class="nc" id="L369">                    new GraphTS&lt;Updater&gt;(updForStage.size());</span>
<span class="nc" id="L370">                BidiMap&lt;Updater, Integer&gt; idx = </span>
<span class="nc" id="L371">                    new BidiMap&lt;Updater, Integer&gt;();</span>

                //Construct a adjacency matrix for dependencies
<span class="nc bnc" id="L374" title="All 2 branches missed.">                for (Updater u : updForStage) {</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                    if (!checkDependencies(u))</span>
<span class="nc" id="L376">                        return false;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">                    if (!idx.containsKey(u)) {</span>
<span class="nc" id="L378">                        int n = graph.addVertex(u);</span>
<span class="nc" id="L379">                        idx.put(u, n);</span>
                    }

<span class="nc bnc" id="L382" title="All 2 branches missed.">                    for (String dependency : u.dependencies()) {</span>
<span class="nc" id="L383">                        Updater dep = getUpdaterByMnemonic(dependency);</span>

                        // Updaters are allowed to introduce self depedencies
<span class="nc bnc" id="L386" title="All 2 branches missed.">                        if (u.equals(dep)) {</span>
<span class="nc" id="L387">                            continue;</span>
                        }

<span class="nc bnc" id="L390" title="All 2 branches missed.">                        if (!idx.containsKey(dep)) {</span>
<span class="nc" id="L391">                            int n = graph.addVertex(dep);</span>
<span class="nc" id="L392">                            idx.put(dep, n);</span>
                        }
<span class="nc" id="L394">                        graph.addEdge(idx.get(u), idx.get(dep));</span>
                    }
                }

                // Topo-sort
<span class="nc" id="L399">                updForStage = graph.topo();</span>

                // We now have updaters in correct execution order
<span class="nc" id="L402">                DependencyJob depJob = new DependencyJob(us.toString());</span>

<span class="nc" id="L404">                List&lt;String&gt; deps = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                if (updater != null)</span>
<span class="nc" id="L406">                    deps = Arrays.asList(updater.dependencies());</span>

<span class="nc bnc" id="L408" title="All 2 branches missed.">                for (Updater u : updForStage) {</span>
                    /*
                     * Ignore the current in case we have an updater specified
                     * as argument unless the updater is the same as the
                     * argument of the current updater is a dependency to the
                     * one we have as argument :-)
                     */
<span class="nc bnc" id="L415" title="All 2 branches missed.">                    if (updater != null &amp;&amp;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                            !updater.equals(u) &amp;&amp;</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">                            !deps.contains(u.mnem())) {</span>
<span class="nc" id="L418">                            continue;</span>
                    }

                    // Create an updater job
<span class="nc" id="L422">                    MetadataUpdater upd = updaters.get(u).newInstance();</span>
<span class="nc" id="L423">                    upd.setUpdateParams(project, logger);</span>

<span class="nc" id="L425">                    UpdaterJob uj = null;</span>
                    /*
                     * If an update has already been scheduled for a specific
                     * updater, just re-use this job for dependency tracking.
                     * Also put the job in the queue of jobs that are about to
                     * be scheduled to allow other jobs to declare dependencies
                     * to it. If in the mean time the dependent job finishes
                     * execution, the dependee will just continue execution.
                     */
<span class="nc bnc" id="L434" title="All 2 branches missed.">                    if (isUpdateRunning(project, u)) {</span>
<span class="nc" id="L435">                        uj = scheduledUpdates.get(project.getId()).get(u);</span>
<span class="nc" id="L436">                    } else {</span>
<span class="nc" id="L437">                        uj = new UpdaterJob(upd);</span>
<span class="nc" id="L438">                        uj.addJobStateListener(this);</span>
<span class="nc" id="L439">                        toSchedule.put(u, uj);</span>
                    }

                    // Add dependency to stage level job
<span class="nc" id="L443">                    depJob.addDependency(uj);</span>
<span class="nc" id="L444">                    jobs.add(uj);</span>
                    
<span class="nc bnc" id="L446" title="All 2 branches missed.">                    if (isUpdateRunning(project, u))</span>
<span class="nc" id="L447">                        continue;</span>
                    
                    //Add dependency to previous stage dependency job
<span class="nc bnc" id="L450" title="All 2 branches missed.">                    if (oldDepJob != null)</span>
<span class="nc" id="L451">                        uj.addDependency(oldDepJob);</span>

                    // Add dependencies to previously scheduled jobs
                    // within the same stage
<span class="nc" id="L455">                    List&lt;Class&lt;? extends MetadataUpdater&gt;&gt; dependencies = </span>
<span class="nc" id="L456">                        new ArrayList&lt;Class&lt;? extends MetadataUpdater&gt;&gt;();</span>

<span class="nc bnc" id="L458" title="All 2 branches missed.">                    for (String s : u.dependencies()) {</span>
<span class="nc" id="L459">                        dependencies.add(updaters.get(getUpdaterByMnemonic(s)));</span>
                    }

<span class="nc bnc" id="L462" title="All 2 branches missed.">                    for (Class&lt;? extends MetadataUpdater&gt; d : dependencies) {</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                        for (Job j : jobs) {</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                            if (!(j instanceof UpdaterJob))</span>
<span class="nc" id="L465">                                continue;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                            if (((UpdaterJob) j).getUpdater().getClass().equals(d)) {</span>
<span class="nc" id="L467">                                uj.addDependency(j);</span>
                            }
                        }
                    }
                }

<span class="nc bnc" id="L473" title="All 2 branches missed.">                if (oldDepJob != null)</span>
<span class="nc" id="L474">                    depJob.addDependency(oldDepJob);</span>

<span class="nc" id="L476">                jobs.add(depJob);</span>
<span class="nc" id="L477">                oldDepJob = depJob;</span>
            }

            //Enqueue jobs
<span class="nc" id="L481">            List&lt;Job&gt; toQueue = new ArrayList&lt;Job&gt;();</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            for (Job job : jobs) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                if (!scheduledUpdates.containsKey(project.getId()))</span>
<span class="nc" id="L484">                    scheduledUpdates.put(project.getId(),</span>
<span class="nc" id="L485">                            new HashMap&lt;Updater, UpdaterJob&gt;());</span>

                //Don't schedule a job that has been scheduled before
<span class="nc" id="L488">                Collection&lt;UpdaterJob&gt; schedJobs = scheduledUpdates.get(project.getId()).values();</span>
<span class="nc" id="L489">                boolean dontSchedule = false;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                for (Job j : schedJobs) {</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">                    if (job.equals(j)) {</span>
<span class="nc" id="L492">                        dontSchedule = true; </span>
<span class="nc" id="L493">                        break;</span>
                    }
                }

<span class="nc bnc" id="L497" title="All 2 branches missed.">                if (dontSchedule) {</span>
<span class="nc" id="L498">                    logger.warn(&quot;Job &quot; + job + &quot; has been scheduled before, ignoring&quot;);</span>
<span class="nc" id="L499">                    continue;</span>
                }
<span class="nc" id="L501">                toQueue.add(job);</span>
                //DependencyJobs don't need to be tracked
<span class="nc bnc" id="L503" title="All 2 branches missed.">                if (!(job instanceof UpdaterJob))</span>
<span class="nc" id="L504">                    continue;</span>
<span class="nc" id="L505">                scheduledUpdates.get(project.getId()).put(</span>
<span class="nc" id="L506">                        toSchedule.getKey(job), (UpdaterJob)job);</span>
            }
<span class="nc" id="L508">            AlitheiaCore.getInstance().getScheduler().enqueueBlock(toQueue);</span>
<span class="nc" id="L509">        } catch (SchedulerException e) {</span>
<span class="nc" id="L510">            logger.error(&quot;Cannot schedule update job(s):&quot; + e.getMessage(), e);</span>
<span class="nc" id="L511">            return false;</span>
<span class="nc" id="L512">        } catch (InstantiationException e) {</span>
<span class="nc" id="L513">            logger.error(&quot;Cannot instantiate updater:&quot; + e.getMessage(), e);</span>
<span class="nc" id="L514">            return false;</span>
<span class="nc" id="L515">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L516">            logger.error(&quot;Cannot load updater class:&quot; + e.getMessage(), e);</span>
<span class="nc" id="L517">            return false;</span>
        }
        
<span class="nc" id="L520">        return true;</span>
    }

    /**
     * Removes an earlier jobs scheduled through addUpdate(). Multiple calls are
     * made to release all the claims in the set.
     * 
     * @param p project to release claims for
     * @param t set of targets to release
     */
    private synchronized void removeUpdater(StoredProject p, Updater u) {
        
<span class="nc bnc" id="L532" title="All 2 branches missed.">        if (p == null) {</span>
<span class="nc" id="L533">            logger.warn(&quot;Cannot remove an update job for a null project&quot;);</span>
<span class="nc" id="L534">            return;</span>
        }
        
<span class="nc" id="L537">        Map&lt;Updater, UpdaterJob&gt; m = scheduledUpdates.get(p.getId());</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (m != null) {</span>
<span class="nc" id="L539">            m.remove(u);</span>
        }
<span class="nc" id="L541">    }</span>

    /**
     * Does a bit of clean up when a job has finished (either by error or
     * normally)
     */
    public synchronized void jobStateChanged(Job j, State newState) {

<span class="nc" id="L549">        Long projectId = null;</span>

<span class="nc bnc" id="L551" title="All 2 branches missed.">        for (Long pid : scheduledUpdates.keySet()) {</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            if (scheduledUpdates.get(pid).containsValue(j)) {</span>
<span class="nc" id="L553">                projectId = pid;</span>
<span class="nc" id="L554">                break;</span>
            }
        }

<span class="nc" id="L558">        Map&lt;Updater, UpdaterJob&gt; updates = scheduledUpdates.get(projectId);</span>
<span class="nc" id="L559">        Updater ut = null;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">        for (Updater t : updates.keySet()) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">            if (updates.get(t).equals(j)) {</span>
<span class="nc" id="L562">                ut = t;</span>
<span class="nc" id="L563">                break;</span>
            }
        }

<span class="nc bnc" id="L567" title="All 4 branches missed.">        if (newState.equals(State.Error) || newState.equals(State.Finished)) {</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">            if (ut == null) {</span>
<span class="nc" id="L569">                logger.error(&quot;Update job finished with state &quot; + newState</span>
<span class="nc" id="L570">                        + &quot; but was not scheduled. That's weird...&quot;);</span>
<span class="nc" id="L571">                return;</span>
            }

<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (!dbs.isDBSessionActive())</span>
<span class="nc" id="L575">                dbs.startDBSession();</span>
<span class="nc" id="L576">            StoredProject sp = StoredProject.loadDAObyId(projectId, StoredProject.class);</span>
<span class="nc" id="L577">            removeUpdater(sp, ut);</span>

<span class="nc bnc" id="L579" title="All 2 branches missed.">            if (newState.equals(State.Error)) {</span>
<span class="nc" id="L580">                logger.warn(ut + &quot; updater job for project &quot; + sp</span>
<span class="nc" id="L581">                        + &quot; did not finish properly&quot;);</span>
            }
<span class="nc" id="L583">            dbs.commitDBSession();</span>
        }
<span class="nc" id="L585">    }</span>
    
    /*Dummy jobs to ensure correct sequencing of jobs within updater stages */
    private class DependencyJob extends Job {
        private String name;
<span class="nc" id="L590">        private DependencyJob(){};</span>
<span class="nc" id="L591">        public DependencyJob(String name) { this.name = name;}</span>
<span class="nc" id="L592">        public long priority() {return 0;}</span>
<span class="nc" id="L593">        protected void run() throws Exception {}</span>
        
        @Override
        public String toString() {
<span class="nc" id="L597">            return &quot;Dependency Job: &quot; + name;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>JUnit (Jan 15, 2015 3:49:07 PM)</div></body></html>