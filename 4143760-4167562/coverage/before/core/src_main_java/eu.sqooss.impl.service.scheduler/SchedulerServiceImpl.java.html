<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>SchedulerServiceImpl.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">JUnit (Jan 15, 2015 3:49:07 PM)</a> &gt; <a href="../../index.html" class="el_group">core</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">eu.sqooss.impl.service.scheduler</a> &gt; <span class="el_source">SchedulerServiceImpl.java</span></div><h1>SchedulerServiceImpl.java</h1><pre class="source lang-java linenums">/*
 * This file is part of the Alitheia system, developed by the SQO-OSS
 * consortium as part of the IST FP6 SQO-OSS project, number 033331.
 *
 * Copyright 2007 - 2010 - Organization for Free and Open Source Software,  
 *                Athens, Greece.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package eu.sqooss.impl.service.scheduler;

import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.PriorityBlockingQueue;

import org.osgi.framework.BundleContext;

import eu.sqooss.service.logging.Logger;
import eu.sqooss.service.scheduler.Job;
import eu.sqooss.service.scheduler.ResumePoint;
import eu.sqooss.service.scheduler.Scheduler;
import eu.sqooss.service.scheduler.SchedulerException;
import eu.sqooss.service.scheduler.SchedulerStats;
import eu.sqooss.service.scheduler.WorkerThread;

public class SchedulerServiceImpl implements Scheduler {

    private static final String START_THREADS_PROPERTY = &quot;eu.sqooss.scheduler.numthreads&quot;;
    private static final String PERF_LOG_PROPERTY = &quot;eu.sqooss.log.perf&quot;;
    
<span class="fc" id="L60">    private Logger logger = null;</span>
<span class="fc" id="L61">    private boolean perfLog = false;</span>

<span class="fc" id="L63">    private SchedulerStats stats = new SchedulerStats();</span>

    // thread safe job queue
<span class="fc" id="L66">    private PriorityQueue&lt;Job&gt; blockedQueue = new PriorityQueue&lt;Job&gt;(1,</span>
<span class="fc" id="L67">            new JobPriorityComparator());</span>
<span class="fc" id="L68">    private BlockingQueue&lt;Job&gt; workQueue = new PriorityBlockingQueue&lt;Job&gt;(1,</span>
<span class="fc" id="L69">            new JobPriorityComparator());</span>

<span class="fc" id="L71">    private BlockingQueue&lt;Job&gt; failedQueue = new ArrayBlockingQueue&lt;Job&gt;(1000);</span>

<span class="fc" id="L73">    private List&lt;WorkerThread&gt; myWorkerThreads = null;</span>
    
<span class="fc" id="L75">    public SchedulerServiceImpl() { }</span>

    public void enqueue(Job job) throws SchedulerException {
<span class="pc" id="L78">        synchronized (this) {</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">            if (logger != null)</span>
<span class="nc" id="L80">                logger.debug(&quot;SchedulerServiceImpl: queuing job &quot; + job.toString());</span>
<span class="fc" id="L81">            job.callAboutToBeEnqueued(this);</span>
<span class="fc" id="L82">            blockedQueue.add(job);</span>
<span class="fc" id="L83">            stats.addWaitingJob(job.getClass().toString());</span>
<span class="fc" id="L84">            stats.incTotalJobs();</span>
        }
<span class="fc" id="L86">        jobDependenciesChanged(job);</span>
<span class="fc" id="L87">    }</span>
    
    public void enqueueNoDependencies(Set&lt;Job&gt; jobs) throws SchedulerException {
<span class="nc" id="L90">        synchronized (this) {</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">            for (Job job : jobs) {</span>
<span class="nc" id="L92">                logger.debug(&quot;Scheduler ServiceImpl: queuing job &quot;</span>
<span class="nc" id="L93">                        + job.toString());</span>
<span class="nc" id="L94">                job.callAboutToBeEnqueued(this);</span>
<span class="nc" id="L95">                workQueue.add(job);</span>
<span class="nc" id="L96">                stats.addWaitingJob(job.getClass().toString());</span>
<span class="nc" id="L97">                stats.incTotalJobs();</span>
            }
        }
<span class="nc" id="L100">    }</span>
    
    public void enqueueBlock(List&lt;Job&gt; jobs) throws SchedulerException {
<span class="nc" id="L103">        synchronized (this) {</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">            for (Job job : jobs) {</span>
<span class="nc" id="L105">                logger.debug(&quot;SchedulerServiceImpl: queuing job &quot; + job.toString());</span>
<span class="nc" id="L106">                job.callAboutToBeEnqueued(this);</span>
<span class="nc" id="L107">                blockedQueue.add(job);</span>
<span class="nc" id="L108">                stats.addWaitingJob(job.getClass().toString());</span>
<span class="nc" id="L109">                stats.incTotalJobs();</span>
            }
        }
<span class="nc bnc" id="L112" title="All 2 branches missed.">        for (Job job : jobs)</span>
<span class="nc" id="L113">            jobDependenciesChanged(job);</span>
<span class="nc" id="L114">    }</span>

    public void dequeue(Job job) {
<span class="nc" id="L117">        synchronized (this) {</span>
<span class="nc bnc" id="L118" title="All 4 branches missed.">            if (!blockedQueue.contains(job) &amp;&amp; !workQueue.contains(job)) {</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">                if (logger != null) {</span>
<span class="nc" id="L120">                    logger.info(&quot;SchedulerServiceImpl: job &quot; + job.toString()</span>
<span class="nc" id="L121">                            + &quot; not found in the queue.&quot;);</span>
                }
<span class="nc" id="L123">                return;</span>
            }
<span class="nc" id="L125">            job.callAboutToBeDequeued(this);</span>
<span class="nc" id="L126">            blockedQueue.remove(job);</span>
<span class="nc" id="L127">            workQueue.remove(job);</span>
        }
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (logger != null) {</span>
<span class="nc" id="L130">            logger.warn(&quot;SchedulerServiceImpl: job &quot; + job.toString()</span>
<span class="nc" id="L131">                    + &quot; not found in the queue.&quot;);</span>
        }
<span class="nc" id="L133">    }</span>

    public Job takeJob() throws java.lang.InterruptedException {
        /*
         * no synchronize needed here, the queue is doing that adding
         * synchronize here would actually dead-lock this, since no new items
         * can be added as long someone is waiting for items
         */
<span class="fc" id="L141">        return workQueue.take();</span>
    }

    public Job takeJob(Job job) throws SchedulerException {
<span class="nc" id="L145">        synchronized (workQueue) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">            if (!workQueue.contains(job)) {</span>
<span class="nc" id="L147">                throw new SchedulerException(&quot;Can't take job &quot; + job</span>
<span class="nc" id="L148">                        + &quot;: It is not in the scheduler's queue right now.&quot;);</span>
            }
<span class="nc" id="L150">            workQueue.remove(job);</span>
<span class="nc" id="L151">            return job;</span>
        }
    }
    
    public void jobStateChanged(Job job, Job.State state) {
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (logger != null) {</span>
<span class="nc" id="L157">            logger.debug(&quot;Job &quot; + job + &quot; changed to state &quot; + state);</span>
        }

<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (state == Job.State.Finished) {</span>
<span class="nc" id="L161">            stats.removeRunJob(job);</span>
<span class="nc" id="L162">            stats.incFinishedJobs();</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        } else if (state == Job.State.Running) {</span>
<span class="fc" id="L164">            stats.removeWaitingJob(job.getClass().toString());</span>
<span class="fc" id="L165">            stats.addRunJob(job);</span>
<span class="pc bnc" id="L166" title="All 2 branches missed.">        } else if (state == Job.State.Yielded) {</span>
<span class="nc" id="L167">            stats.removeRunJob(job);</span>
<span class="nc" id="L168">            stats.addWaitingJob(job.getClass().toString());</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        } else if (state == Job.State.Error) {</span>

<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (failedQueue.remainingCapacity() == 1)</span>
<span class="nc" id="L172">                failedQueue.remove();</span>
<span class="nc" id="L173">            failedQueue.add(job);</span>
            
<span class="nc" id="L175">            stats.removeRunJob(job);</span>
<span class="nc" id="L176">            stats.addFailedJob(job.getClass().toString());</span>
        }
<span class="fc" id="L178">    }</span>

    public void jobDependenciesChanged(Job job) {
<span class="pc" id="L181">        synchronized (this) {</span>
<span class="pc bpc" id="L182" title="3 of 4 branches missed.">            if (workQueue.contains(job) &amp;&amp; !job.canExecute()) {</span>
<span class="nc" id="L183">                workQueue.remove(job);</span>
<span class="nc" id="L184">                blockedQueue.add(job);</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            } else if (job.canExecute()) {</span>
<span class="fc" id="L186">                blockedQueue.remove(job);</span>
<span class="fc" id="L187">                workQueue.add(job);</span>
            }
        }
<span class="fc" id="L190">    }</span>

    public void startExecute(int n) {
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (logger != null)</span>
<span class="nc" id="L194">            logger.info(&quot;Starting &quot; + n + &quot; worker threads&quot;);</span>
<span class="pc" id="L195">        synchronized (this) {</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">            if (myWorkerThreads == null) {</span>
<span class="fc" id="L197">                myWorkerThreads = new LinkedList&lt;WorkerThread&gt;();</span>
            }

<span class="fc bfc" id="L200" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L201">                WorkerThread t = new WorkerThreadImpl(this, i);</span>
<span class="fc" id="L202">                t.start();</span>
<span class="fc" id="L203">                myWorkerThreads.add(t);</span>
<span class="fc" id="L204">                stats.incWorkerThreads();</span>
            }
        }
<span class="fc" id="L207">    }</span>

    public void stopExecute() {
<span class="pc" id="L210">        synchronized (this) {</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            if (myWorkerThreads == null) {</span>
<span class="nc" id="L212">                return;</span>
            }

<span class="fc bfc" id="L215" title="All 2 branches covered.">            for (WorkerThread t : myWorkerThreads) {</span>
<span class="fc" id="L216">                t.stopProcessing();</span>
<span class="fc" id="L217">                stats.decWorkerThreads();</span>
            }

<span class="fc" id="L220">            myWorkerThreads.clear();</span>
        }
<span class="fc" id="L222">    }</span>

    synchronized public boolean isExecuting() {
<span class="pc" id="L225">        synchronized (this) {</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">            if (myWorkerThreads == null) {</span>
<span class="nc" id="L227">                return false;</span>
            } else {
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">                return !myWorkerThreads.isEmpty();</span>
            }
        }
    }

    public SchedulerStats getSchedulerStats() {
<span class="fc" id="L235">        return stats;</span>
    }

    public Job[] getFailedQueue() {
<span class="nc" id="L239">        Job[] failedJobs = new Job[failedQueue.size()];</span>
<span class="nc" id="L240">        return failedQueue.toArray(failedJobs);</span>
    }

    public WorkerThread[] getWorkerThreads() {
<span class="nc" id="L244">        return (WorkerThread[]) this.myWorkerThreads.toArray();</span>
    }

    public void startOneShotWorkerThread() {
<span class="nc" id="L248">        WorkerThread t = new WorkerThreadImpl(this, true);</span>
<span class="nc" id="L249">        t.start();</span>
<span class="nc" id="L250">    }</span>

	@Override
	public void setInitParams(BundleContext bc, Logger l) {
<span class="nc" id="L254">		this.logger = l;</span>
<span class="nc" id="L255">	}</span>

	@Override
	public void shutDown() {
<span class="nc" id="L259">	}</span>

	@Override
	public boolean startUp() {
        
<span class="nc" id="L264">        int numThreads = 2 * Runtime.getRuntime().availableProcessors(); </span>
<span class="nc" id="L265">        String threadsProperty = System.getProperty(START_THREADS_PROPERTY);</span>
        
<span class="nc bnc" id="L267" title="All 4 branches missed.">        if (threadsProperty != null &amp;&amp; !threadsProperty.equals(&quot;-1&quot;)) {</span>
            try {
<span class="nc" id="L269">                numThreads = Integer.parseInt(threadsProperty);</span>
<span class="nc" id="L270">            } catch (NumberFormatException nfe) {</span>
<span class="nc" id="L271">                logger.warn(&quot;Invalid number of threads to start:&quot; + threadsProperty);</span>
            }
        }
<span class="nc" id="L274">        startExecute(numThreads);</span>
        
<span class="nc" id="L276">        String perfLog = System.getProperty(PERF_LOG_PROPERTY);</span>
<span class="nc bnc" id="L277" title="All 4 branches missed.">        if (perfLog != null &amp;&amp; perfLog.equals(&quot;true&quot;)) {</span>
<span class="nc" id="L278">            logger.info(&quot;Using performance logging&quot;);</span>
<span class="nc" id="L279">            this.perfLog = true;</span>
        }

<span class="nc" id="L282">        return true;</span>
	}

    @Override
    public boolean createAuxQueue(Job j, Deque&lt;Job&gt; jobs, ResumePoint p)
            throws SchedulerException {
        
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (jobs.isEmpty()) {</span>
<span class="nc" id="L290">            logger.warn(&quot;Empty job queue passed to createAuxQueue(). Ignoring request&quot;);</span>
<span class="nc" id="L291">            return false;</span>
        }
        
<span class="nc" id="L294">        j.yield(p);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        for (Job job : jobs) {</span>
<span class="nc" id="L296">            j.addDependency(job);</span>
<span class="nc" id="L297">            enqueue(job);</span>
        }
<span class="nc" id="L299">        return true;</span>
    }

    @Override
    public synchronized void yield(Job j, ResumePoint p) throws SchedulerException {
        
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (j.state() != Job.State.Yielded)</span>
<span class="nc" id="L306">            j.yield(p);</span>
<span class="nc" id="L307">        workQueue.remove(j);</span>
<span class="nc" id="L308">        blockedQueue.add(j);</span>
<span class="nc" id="L309">    }</span>
}

//vi: ai nosi sw=4 ts=4 expandtab
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>JUnit (Jan 15, 2015 3:49:07 PM)</div></body></html>