<h1>IN4189 Software Reengineering - Reverse Engineering and Detection Report</h1>

<p>By Martijn den Hoedt - 4143760, Anton Bouter - 4167562</p>

<h2>Introduction</h2>

<p><a href="http://www.sqo-oss.org/">Alitheia Core</a> is a platform for automatic evaluation of software that is designed to simplify software engineering research. It can produce a broad picture of the quality of an Open Source project by analysing both hard project artifacts (source code) and soft project artifacts (mailing list, bug tracker entries).
We performed a software analysis on the Alitheia Core to find shortcoming such as design flaws and code smells. The first chapter of this report will describe the system and its structure, while the second chapter is dedicated to pinpointing shortcomings of the Alitheia Core. The focus is on detecting violations of the S.O.L.I.D. object-oriented design principles. These include the following five principles:</p>

<ul>
<li>Single responsibility principle</li>
<li>Open/closed principle</li>
<li>Liskov substitution principle</li>
<li>Interface segregation principle</li>
<li>Dependency inversion principle</li>
</ul>

<p>To simplify the detection procedure, the following software evaluation tools have been used: </p>

<ul>
<li><a href="http://www.sonarqube.org/">SonarQube</a>
<ul>
<li>Open platform to manage code quality, which covers criteria such as complexity, potential bugs, duplications, architecture &amp; design.</li>
</ul></li>
<li><a href="https://www.intooitus.com/products/incode">inCode</a>
<ul>
<li>Detects design flaws automatically and helps you resolve them.</li>
</ul></li>
<li><a href="http://xray.inf.usi.ch/xray.php">X-Ray</a>
<ul>
<li>Software visualization tool that provides e.g. a system complexity form and a class and package dependency view.</li>
</ul></li>
<li><a href="http://www.umlgraph.org/">UMLGraph</a>
<ul>
<li>Allows automatic drawing of UML class and sequence diagrams</li>
</ul></li>
</ul>

<h2>Initial Understanding and Detailed Model Capture</h2>

<p>To find certain shortcomings in the design of the system, we must first understand it. This chapter is dedicated to the process of understanding the model and displaying its properties clearly by using reverse engineering tools to create models.</p>

<h3>Main features</h3>

<p>What makes Alitheia Core stand out is that it not only evaluates the final product, but also the developing process. This is done by evaluating the so called soft project artifacts, such as mailing lists and bug tracker entries, which leads to a broader picture of the quality of the software project. The different aspects of that are analysed are aggregated through a <a href="http://www.dmst.aueb.gr/dds/pubs/conf/2008-OSS-qmodel/html/SGSS08.htm">multilevel quality model</a> <a href="http://www.sqo-oss.org/about">[1]</a>.</p>

<p>The Alitheia Core can also be used to automate and parallellize the execution of custom experiments. Studies on empirical data can easily be performed and the Alitheia Core can also be extended to produce any measurement you are interested in.</p>

<h3>Important source code entities</h3>

<p>The main class of the Alitheia Core is AlitheiaCore.java, in the eu.sqooss.core package, which initializes the core components of the system and provides a static instance of AlitheiaCore. All services of the AlitheiaCore classes can then be called by using the methods defined in the AlitheiaCoreService interface, which is present in the same package as the AlitheiaCore class. These services are implemented in the eu.sqooss.service package and divided into a large number of packages, such as admin, db, scheduler, updater and util. Each package can also contain classes that the service depends on.</p>

<h3>Impression of design and implementation</h3>

<p>We think that the Alitheia Core system looks well structured, because the classes seem to be properly distributed among packages with names that provide useful information. The core is properly isolated from the classes that provide services. Many classes also contain javadoc comments and additional comments to clarify functions when needed. However, the number of tests is very limited. We therefore have a relatively good first impression of the design and implementation of the system. Although the test suite should be expanded, we think reengineering the Alitheia Core is feasible, because the javadoc documentation makes it much easier.</p>

<h3>Exceptional entities</h3>

<p>To study the exceptional entities, such as packages, classes and methods, a UML diagram can be very useful. Such a diagram shows which classes are related and in what way. A UML diagram can also be reverse engineered by a tool such as <a href="http://www.umlgraph.org/">UMLGraph</a>. The diagram in figure 1 displays all database objects and was created by Georgios Gousios using the UMLGraph tool on the Alitheia Core system <a href="http://www.umlgraph.org/doc/ceg-er.html">[2]</a>. From this diagram we can clearly see that many classes depend on the StoredProject class. The same goes for the Metric, ProjectVersion and Bug classes. All of these classes are part of the eu.sqooss.service.db package, which definitely is an exceptional entity, because it contains a very large number of classes. </p>

<p><img src="./img/uml.png" width="931" height="437px" /></p>

<p><center><em>Figure 1: UML Diagram of Alitheia Core</em></center></p>

<h3>Inheritance structure</h3>

<p>As described earlier, the system is composed of many service interfaces that extend the AlitheiaCoreService interface, such as DBService, AdminService, LogManager and RestService. The implementations of all these classes must also implement the basic functions of the AlitheiaCoreService class.</p>

<h3>Step through execution</h3>

<p>Finally, collisions are handled by locking the database whenever a thread starts a database session, such that no other threads can commit changes to the database. When changes are committed, the current session is closed and the lock on the database is released. The changes made during the current session can also be reverted by the function rollbackDBSession in DBService.</p>

<h2>Problem Detection</h2>

<p><a href="https://www.intooitus.com/products/incode">inCode</a> found nine God classes, two of them are scoring a 10 out of 10 (<code>GitUpdater</code> and <code>ContributionMetricImpl</code>). The <code>GitUpdater</code> 767 LOC, but another bigger class called <code>SVNUUpdaterImpl</code> has 993 LOC. </p>

<h3>Single Responsibility Principle</h3>

<p>Both the <code>ContributionMetrixImpl</code> and the <code>GitUpdater</code> classes have many methods, use many attributes from many external classes. The <code>GitUpdater</code> class also contains multiple to-do's and code that is commented out. These two classes keep track of many things and can perform many actions, therefore they violate the single responsbility principle. Another example is the definition of <code>DecreasingLongComparator</code> and <code>RandomizedCompatator</code> within <code>MetricActivatorImpl.java</code>. In this way it's not easy to know such classes actually exists, not to mention reusing the code. </p>

<h3>Open/Closed Principle (OCP) or Liskov Substitution Principle (LSP)</h3>

<h3>Dependency Inversion Principle (DIP)</h3>

<h3>Acyclic Dependencies Principle (ADP)</h3>

<h3>Don't Repeat Yourself (DRY)</h3>

<p>We have looked for duplicated code with <a href="http://www.sonarqube.org/">SonarQube</a>. This tool found 313 lines of code (LOC) in a total of 31,760 LOC. Thus only 1% of the Alitheia Core project is duplicate code. The project contains 15,688 LOC with Java, the rest is comments or whitespace. We investigated a few instances of code duplication. One of them is <code>BugResolution</code> (lines 121-135) and <code>BTSEntry</code> (lines 203-216). </p>

<h3>Simple shortcomings</h3>

<p>SonarQube is also able to detect a lot of other issues. In Alitheia Core are 1770 issues. These issues can point out confusing code formatting, like inconsistently placing curly braces. Also more important issues like never throw generic exceptions, such as <code>Exception</code>, are detected in the Alitheia Core project.</p>

<p>SonarQube is also able to calculate the complexicity of the code. The <a href="http://docs.codehaus.org/display/SONAR/Metrics+-+Complexity">complexity metrics</a> used by SonarQube is count every  <code>if</code>, <code>for</code>, <code>while</code>, <code>case</code>, <code>catch</code>, <code>throw</code> and <code>return</code> statement. The <code>PluginsView</code> has the highest complexity per function, but also a high amount of code per method. inCode also found classes and methods with a high complexcity.</p>
